# Fill in your name, student ID, and email address in this file.
# If you are working in a team, fill out the information for both team 
# members.

# SUBMIT THE LAB ONLY ONCE (from only one partner). This file will be
# automatically parsed in order to give both team members credit for the
# lab.

# You need to fill in the EXERCISE sections describing your solutions
# for Tasks 1, 2, and 3, as well as write the corresponding code.
# If you did one or more extra credit problems, indicate which one in the
# appropriate section below (remove the # sign first). If you have any other
# information you'd like us to know, please add it at the end of the file.

# Partner 1
Name: Guanya Yang
Student ID: 204378262
Email: guayang@ucla.edu

# Partner 2 (if you're working in a team)
Name: Yu Xie
Student ID: 204398665
Email: zjuxie@gmail.com

# EXERCISE 1: What method you used to make your peer download and upload
#    files in parallel?  (~1-3 sentences)

We implemented the concurrency using forks for the download and upload sections. This way, the child processes will deal with the individual downloads and uploads so that the main process won’t get blocked.

# EXERCISE 2A: What conditions did you find and fix that would have
#    triggered a buffer overrun bug?  (~1-3 sentences each)

1. The Linux maximum filename 256, but osppeer.c doesn’t check for the filename length when uploading files. We fixed this bug by using the constant FILENAMESIZ defined at the beginning of osppeer.c.
	
# EXERCISE 2B: What other robustness problems did you fix?  (~1-3 sentences
#    each)

1. We prevented the peer from serving any files outside of its current directory by examining the filename string and seeing if it contained any “/” characters.
2. If a peer receives a file request, it will write the file data into its task buffer, along with an associated file descriptor. The requesting peer would then read from the buffer in order to download the file. However, if the requesting peer does not read from the file, the resources from the buffer  and the file descriptor will never be released.
(also downloading from empty buffer)

# EXERCISE 3: Describe the attacks you implemented for "evil mode".  Why
#    are they attacks?  (~3-10 sentences each)
-pick a victim, register as victim on tracker with IP and port number, register lots of files so that a lot of peers will attempt to download from the victim—> run out of resources
-register malicious file in different/popular name to trick other downloading peers

# Extra credit problems
#Extra credit problem:
Check MD5 before download file from tracker, download the file from peer, check MD5 again (if the same, we’re ok, else, the file is corrupted)

# Add any other information you'd like us to know below this line.


To-Do:
-implement 2, 3, extra credit
-flesh out answers